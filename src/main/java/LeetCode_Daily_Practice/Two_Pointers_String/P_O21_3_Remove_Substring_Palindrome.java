package LeetCode_Daily_Practice.Two_Pointers_String;

import org.testng.Assert;
import org.testng.annotations.Test;

public class P_O21_3_Remove_Substring_Palindrome {

    /*
    leetcode.com/problems/remove-palindromic-subsequences/

    You are given a string s consisting only of letters 'a' and 'b'.
    In a single step you can remove one palindromic subsequence from s.
    Return the minimum number of steps to make the given string empty.
    A string is a subsequence of a given string if it is generated by deleting
    some characters of a given string without changing its order.
    Note that a subsequence does not necessarily need to be contiguous.

    A string is called palindrome if is one that reads the same backward as well as forward.

    Constraints:
    1 <= s.length <= 1000
    s[i] is either 'a' or 'b'.

Input: s = "baabb"
Explanation: "baabb" -> "b" -> "".
Remove palindromic subsequence "baab" then "b".
*/
    @Test
    public void example1(){
        String words="ababa";
        Assert.assertEquals(subStringPal(words), 1);
    }

    @Test
    public void example2(){
        String words="abb";
        Assert.assertEquals(subStringPal(words), 2);
    }

    @Test
    public void example3(){
        String words="baabb";
        Assert.assertEquals(subStringPal(words), 2);
    }

    @Test
    public void example4(){
        String words="aaabbaa";
        Assert.assertEquals(subStringPal(words), 2);
    }

/*
1. convert the string to char array
2. consider two pointer from one end
3. if char between i and j is palindrome
	- then add it in to set
	- change i=j and j=j+1
4. continue till the array end
*/
    private int subStringPal(String word) {
        if (word.length() < 1) return 0;
        else if (word.equals(reverseWord(word))) return 1;
        else return 2;
    }

    public String reverseWord(String word){
        if(word.length()<2) return word;

        char[] ch = word.trim().toCharArray();
        char c;
        int left=0, right=word.length()-1;

        while(left<right){//=>O(n)
            if(ch[left]>=97 && ch[right]<=98){
                c=ch[left];
                ch[left++]=ch[right];
                ch[right--]=c;
            }
        }
        return String.valueOf(ch);
    }

    public int removePalindromeSubBF(String word) {
        int left=0, right=word.length()-1;
        if (word.length() < 1) return 0;
        while(left<right){
            if(word.charAt(left)==word.charAt(right)){
                left++;
                right--;
            }else return 2;
        }
        return 1;
    }
}
